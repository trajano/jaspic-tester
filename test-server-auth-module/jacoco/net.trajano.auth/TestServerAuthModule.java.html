<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TestServerAuthModule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Test Server Auth Module</a> &gt; <a href="index.source.html" class="el_package">net.trajano.auth</a> &gt; <span class="el_source">TestServerAuthModule.java</span></div><h1>TestServerAuthModule.java</h1><pre class="source lang-java linenums">package net.trajano.auth;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URLEncoder;
import java.security.Principal;
import java.util.Iterator;
import java.util.Map;
import java.util.logging.Logger;

import javax.security.auth.Subject;
import javax.security.auth.callback.Callback;
import javax.security.auth.callback.CallbackHandler;
import javax.security.auth.callback.UnsupportedCallbackException;
import javax.security.auth.message.AuthException;
import javax.security.auth.message.AuthStatus;
import javax.security.auth.message.MessageInfo;
import javax.security.auth.message.MessagePolicy;
import javax.security.auth.message.callback.CallerPrincipalCallback;
import javax.security.auth.message.callback.GroupPrincipalCallback;
import javax.security.auth.message.config.ServerAuthContext;
import javax.security.auth.message.module.ServerAuthModule;
import javax.servlet.ServletException;
import javax.servlet.http.Cookie;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.core.UriBuilder;

/**
 * &lt;p&gt;
 * This is a JASPIC {@link ServerAuthModule} used for testing purposes.
 * &lt;/p&gt;
 * &lt;p&gt;
 * The module will detect if the user is not yet authenticated to a simple web
 * form that asks for a user name. It forms a subject with the pattern
 * &lt;/p&gt;
 *
 * &lt;pre&gt;
 * https://[username]@test-server-auth-module
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The module does not make use of &lt;code&gt;HttpSession&lt;/code&gt; but instead uses a
 * cookie &lt;code&gt;X-Subject&lt;/code&gt; to store the subject.
 * &lt;/p&gt;
 *
 * @author Archimedes Trajano
 */
<span class="fc" id="L49">public class TestServerAuthModule implements</span>
    ServerAuthModule,
    ServerAuthContext {

    /**
     * Groups associated to the user.
     */
<span class="fc" id="L56">    private static final String[] GROUPS = {</span>
        &quot;authenticated&quot;
    };

    /**
     * Logger.
     */
<span class="fc" id="L63">    private static final Logger LOG = Logger.getLogger(TestServerAuthModule.class.getName());</span>

    /**
     * Login endpoint.
     */
    public static final String LOGIN_ENDPOINT = &quot;/j_security_check&quot;;

    /**
     * Logout endpoint.
     */
    public static final String LOGOUT_ENDPOINT = &quot;/j_logout&quot;;

    /**
     * Post logout redirect URI. The value is used to make it consistent with
     * OpenID Connect specifications.
     */
    public static final String POST_LOGOUT_REDIRECT_URI = &quot;post_logout_redirect_uri&quot;;

    /**
     * Request parameter for state. &lt;code&gt;state&lt;/code&gt; is used to make it
     * consistent with OpenID Connect specifications.
     */
    public static final String STATE = &quot;state&quot;;

    /**
     * Subject cookie key.
     */
    public static final String SUBJECT_COOKIE_KEY = &quot;X-Subject&quot;;

    /**
     * Obtains the subject from the cookies in the HttpServletRequest.
     *
     * @param req
     *            servlet request
     * @return subject may be null if not found
     */
    private static String getSubject(final HttpServletRequest req) {

<span class="fc" id="L101">        String subjectCookie = null;</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">        if (req.getCookies() != null) {</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">            for (final Cookie cookie : req.getCookies()) {</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">                if (SUBJECT_COOKIE_KEY.equals(cookie.getName())) {</span>
<span class="fc" id="L105">                    subjectCookie = cookie.getValue();</span>
                }
            }
        }
<span class="fc" id="L109">        return subjectCookie;</span>
    }

    /**
     * Handle the login endpoint. This will display the login page and will
     * handle login POST action.
     *
     * @param req
     *            request
     * @param resp
     *            response
     * @return authentication status
     * @throws AuthException
     *             happens when there is invalid request data
     * @throws IOException
     *             servlet error
     * @throws ServletException
     *             servlet error
     */
    private static AuthStatus handleLoginEndpoint(final HttpServletRequest req,
        final HttpServletResponse resp) throws ServletException,
            AuthException,
            IOException {

<span class="fc bfc" id="L133" title="All 2 branches covered.">        if (!req.isSecure()) {</span>
<span class="fc" id="L134">            throw new AuthException(&quot;Secure connection is required&quot;);</span>
        }

<span class="fc" id="L137">        final String state = req.getParameter(STATE);</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (state == null) {</span>
<span class="fc" id="L139">            throw new AuthException(&quot;missing 'state' parameter&quot;);</span>
        }

        // Ensure that the state is valid, it should be relative
<span class="fc" id="L143">        final URI stateUri = URI.create(state).normalize();</span>
<span class="fc" id="L144">        validateStateUri(stateUri);</span>

<span class="fc bfc" id="L146" title="All 2 branches covered.">        if (&quot;GET&quot;.equals(req.getMethod())) {</span>
<span class="fc" id="L147">            return handleLoginGet(req, resp);</span>
<span class="fc bfc" id="L148" title="All 2 branches covered.">        } else if (&quot;POST&quot;.equals(req.getMethod())) {</span>
<span class="fc" id="L149">            return handleLoginPost(req, resp, stateUri);</span>
        } else {
<span class="fc" id="L151">            throw new AuthException(&quot;unsupported method&quot;);</span>
        }
    }

    /**
     * Handles the GET method for login endpoint.
     *
     * @param req
     *            request
     * @param resp
     *            response
     * @return {@link AuthStatus#SEND_SUCCESS}
     * @throws IOException
     *             servlet error
     * @throws ServletException
     *             servlet error
     */
    private static AuthStatus handleLoginGet(final HttpServletRequest req,
        final HttpServletResponse resp) throws ServletException,
            IOException {

<span class="fc" id="L172">        req.getRequestDispatcher(&quot;/WEB-INF/login.jsp&quot;).forward(req, resp);</span>
<span class="fc" id="L173">        return AuthStatus.SEND_SUCCESS;</span>
    }

    /**
     * Handles the POST method for login endpoint.
     *
     * @param req
     *            request
     * @param resp
     *            response
     * @param stateUri
     *            URI for the state
     * @return {@link AuthStatus#SEND_SUCCESS}
     * @throws IOException
     *             servlet error
     * @throws ServletException
     *             servlet error
     * @throws AuthException
     *             authentication error
     */
    private static AuthStatus handleLoginPost(final HttpServletRequest req,
        final HttpServletResponse resp,
        final URI stateUri) throws ServletException,
            IOException,
            AuthException {

<span class="fc" id="L199">        final String subject = UriBuilder.fromUri(&quot;https://test-server-auth-module&quot;).userInfo(req.getParameter(&quot;j_username&quot;))</span>
            .build().toASCIIString();
<span class="fc" id="L201">        final Cookie cookie = new Cookie(SUBJECT_COOKIE_KEY, subject);</span>
<span class="fc" id="L202">        cookie.setSecure(true);</span>
<span class="fc" id="L203">        cookie.setHttpOnly(true);</span>
<span class="fc" id="L204">        resp.addCookie(cookie);</span>
<span class="fc" id="L205">        resp.sendRedirect(URI.create(req.getContextPath() + stateUri.toASCIIString()).normalize().toASCIIString());</span>
<span class="fc" id="L206">        return AuthStatus.SEND_SUCCESS;</span>
    }

    /**
     * Handle the logout endpoint. This will clear the cookie and redirect to
     * the URI that has been specified.
     *
     * @param req
     *            request
     * @param resp
     *            response
     * @return authentication status
     * @throws AuthException
     *             happens when there is invalid request data
     * @throws IOException
     *             servlet error
     * @throws ServletException
     *             servlet error
     */
    private static AuthStatus handleLogoutEndpoint(final HttpServletRequest req,
        final HttpServletResponse resp) throws AuthException,
            ServletException,
            IOException {

<span class="fc" id="L230">        final String postLogoutRedirectUri = req.getParameter(POST_LOGOUT_REDIRECT_URI);</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">        if (postLogoutRedirectUri != null) {</span>

<span class="fc" id="L233">            final String postLogoutRedirectUriNormalized = URI.create(postLogoutRedirectUri).normalize().toASCIIString();</span>
            // Check that the post logout redirect uri is relative to the application if not fail.
<span class="fc" id="L235">            final String contextUri = URI.create(req.getRequestURL().toString()).resolve(req.getContextPath()).toASCIIString();</span>
<span class="fc bfc" id="L236" title="All 2 branches covered.">            if (!postLogoutRedirectUriNormalized.startsWith(contextUri)) {</span>
<span class="fc" id="L237">                throw new AuthException(&quot;invalid post_logout_redirect_uri&quot;);</span>
            }

<span class="fc" id="L240">            final Cookie cookie = new Cookie(SUBJECT_COOKIE_KEY, &quot;&quot;);</span>
<span class="fc" id="L241">            cookie.setMaxAge(0);</span>
<span class="fc" id="L242">            cookie.setSecure(true);</span>
<span class="fc" id="L243">            resp.addCookie(cookie);</span>
<span class="fc" id="L244">            resp.sendRedirect(postLogoutRedirectUriNormalized);</span>
<span class="fc" id="L245">            return AuthStatus.SEND_SUCCESS;</span>
        }
<span class="fc" id="L247">        throw new AuthException(&quot;missing post_logout_redirect_uri&quot;);</span>
    }

    /**
     * Builds the redirect URI including the assembly of &lt;code&gt;state&lt;/code&gt;.
     *
     * @param req
     *            servlet request
     * @param resp
     *            servlet response
     * @return {@link AuthStatus#SEND_SUCCESS}
     * @throws AuthException
     *             happens when there is invalid request data
     * @throws IOException
     *             servlet error
     * @throws ServletException
     *             servlet error
     */
    private static AuthStatus handleRedirectToLoginEndpoint(final HttpServletRequest req,
        final HttpServletResponse resp) throws AuthException,
            ServletException,
            IOException {

<span class="fc bfc" id="L270" title="All 2 branches covered.">        if (!&quot;GET&quot;.equals(req.getMethod())) {</span>
<span class="fc" id="L271">            throw new AuthException(&quot;Only 'GET' method is supported when redirecting to the endpoint&quot;);</span>
        }
<span class="fc" id="L273">        final StringBuilder stateBuilder = new StringBuilder(req.getRequestURI().substring(req.getContextPath().length()));</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">        if (req.getQueryString() != null) {</span>
<span class="fc" id="L275">            stateBuilder.append('?');</span>
<span class="fc" id="L276">            stateBuilder.append(req.getQueryString());</span>
        }
<span class="fc" id="L278">        final StringBuilder redirectUriBuilder = new StringBuilder(req.getContextPath());</span>
<span class="fc" id="L279">        redirectUriBuilder.append(LOGIN_ENDPOINT);</span>
<span class="fc" id="L280">        redirectUriBuilder.append(&quot;?state=&quot;);</span>
<span class="fc" id="L281">        redirectUriBuilder.append(</span>
            URLEncoder.encode(stateBuilder.toString(), &quot;US-ASCII&quot;));
<span class="fc" id="L283">        resp.sendRedirect(URI.create(redirectUriBuilder.toString()).normalize().toASCIIString());</span>

        // The JASPIC spec is ambiguous for this scenario, however
        // SEND_SUCCESS works on the top three application servers.

<span class="fc" id="L288">        return AuthStatus.SEND_SUCCESS;</span>
    }

    /**
     * Validates the state URI. It ensures that it is:
     * &lt;ul&gt;
     * &lt;li&gt;an absolute URI, no &lt;code&gt;http:&lt;/code&gt; or any other scheme
     * definition.
     * &lt;li&gt;It has no host component.
     * &lt;li&gt;Path must start with &lt;code&gt;/&lt;/code&gt;
     * &lt;li&gt;Path must not contain &lt;code&gt;/..&lt;/code&gt;
     * &lt;/ul&gt;
     *
     * @param stateUri
     *            URI to evaluate
     * @throws AuthException
     *             validation failure
     */
    private static void validateStateUri(final URI stateUri) throws AuthException {

<span class="fc bfc" id="L308" title="All 2 branches covered.">        if (stateUri.isAbsolute()) {</span>
<span class="fc" id="L309">            throw new AuthException(&quot;'state' must not be an absolute URI&quot;);</span>
        }
<span class="fc bfc" id="L311" title="All 2 branches covered.">        if (stateUri.getHost() != null) {</span>
<span class="fc" id="L312">            throw new AuthException(&quot;'state' must not have a host component&quot;);</span>
        }
<span class="fc bfc" id="L314" title="All 2 branches covered.">        if (!stateUri.getPath().startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L315">            throw new AuthException(&quot;'state' must start with '/'&quot;);</span>
        }
<span class="fc bfc" id="L317" title="All 2 branches covered.">        if (stateUri.getPath().contains(&quot;/..&quot;)) {</span>
<span class="fc" id="L318">            throw new AuthException(&quot;'state' must not resolve to a parent path&quot;);</span>
        }
<span class="fc" id="L320">    }</span>

    /**
     * Callback handler that is passed in initialize by the container. This
     * processes the callbacks which are objects that populate the &quot;subject&quot;.
     */
    private CallbackHandler handler;

    /**
     * Mandatory flag.
     */
    private boolean mandatory;

    /**
     * Removes the &lt;code&gt;authenticated&lt;/code&gt; group and the user ID from the
     * principal set.
     *
     * @param messageInfo
     *            message info
     * @param subject
     *            subject
     */
    @Override
    public void cleanSubject(final MessageInfo messageInfo,
        final Subject subject) throws AuthException {

<span class="fc" id="L346">        final HttpServletRequest req = (HttpServletRequest) messageInfo.getRequestMessage();</span>
<span class="fc" id="L347">        final String subjectCookie = getSubject(req);</span>

<span class="fc" id="L349">        final Iterator&lt;Principal&gt; iterator = subject.getPrincipals().iterator();</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        while (iterator.hasNext()) {</span>
<span class="fc" id="L351">            final Principal principal = iterator.next();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            if (&quot;authenticated&quot;.equals(principal.getName())) {</span>
<span class="fc" id="L353">                iterator.remove();</span>
            }
<span class="fc bfc" id="L355" title="All 2 branches covered.">            if (principal.getName().equals(subjectCookie)) {</span>
<span class="fc" id="L356">                iterator.remove();</span>
            }
<span class="fc" id="L358">        }</span>
        // Does nothing.
<span class="fc" id="L360">    }</span>

    /**
     * &lt;p&gt;
     * Supported message types. For our case we only need to deal with HTTP
     * servlet request and responses. On Java EE 7 this will handle WebSockets
     * as well.
     * &lt;/p&gt;
     * &lt;p&gt;
     * This creates a new array for security at the expense of performance.
     * &lt;/p&gt;
     *
     * @return {@link HttpServletRequest} and {@link HttpServletResponse}
     *         classes.
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    @Override
    public Class[] getSupportedMessageTypes() {

<span class="fc" id="L379">        return new Class&lt;?&gt;[] {</span>
            HttpServletRequest.class,
            HttpServletResponse.class
        };
    }

    /**
     * {@inheritDoc}
     *
     * @param requestPolicy
     *            request policy, ignored
     * @param responsePolicy
     *            response policy, ignored
     * @param h
     *            callback handler
     * @param options
     *            options
     */
    @Override
    public void initialize(final MessagePolicy requestPolicy,
        final MessagePolicy responsePolicy,
        final CallbackHandler h,
        @SuppressWarnings(&quot;rawtypes&quot;) final Map options) throws AuthException {

<span class="fc" id="L403">        handler = h;</span>
<span class="fc" id="L404">        mandatory = requestPolicy.isMandatory();</span>
<span class="fc" id="L405">    }</span>

    /**
     * Return {@link AuthStatus#SEND_SUCCESS}.
     *
     * @param messageInfo
     *            contains the request and response messages. At this point the
     *            response message is already committed so nothing can be
     *            changed.
     * @param subject
     *            subject.
     * @return {@link AuthStatus#SEND_SUCCESS}
     */
    @Override
    public AuthStatus secureResponse(final MessageInfo messageInfo,
        final Subject subject) throws AuthException {

<span class="fc" id="L422">        return AuthStatus.SEND_SUCCESS;</span>
    }

    /**
     * &lt;p&gt;
     * Checks for the presence of the cookie, if it is present it will use that
     * as the subject if not it will redirect to a login screen.
     * &lt;/p&gt;
     * {@inheritDoc}
     */
    @Override
    public AuthStatus validateRequest(final MessageInfo messageInfo,
        final Subject client,
        final Subject serviceSubject)
            throws AuthException {

<span class="fc" id="L438">        final HttpServletRequest req = (HttpServletRequest) messageInfo.getRequestMessage();</span>
<span class="fc" id="L439">        final HttpServletResponse resp = (HttpServletResponse) messageInfo.getResponseMessage();</span>
        try {

<span class="fc" id="L442">            final String localRequestUri = req.getRequestURI().substring(req.getContextPath().length());</span>

<span class="fc bfc" id="L444" title="All 2 branches covered.">            if (LOGIN_ENDPOINT.equals(localRequestUri)) {</span>
<span class="fc" id="L445">                return handleLoginEndpoint(req, resp);</span>
            }

<span class="fc bfc" id="L448" title="All 2 branches covered.">            if (LOGOUT_ENDPOINT.equals(localRequestUri)) {</span>
<span class="fc" id="L449">                return handleLogoutEndpoint(req, resp);</span>
            }

            // Allow if authentication is not required.
<span class="fc bfc" id="L453" title="All 2 branches covered.">            if (!mandatory) {</span>
<span class="fc" id="L454">                return AuthStatus.SUCCESS;</span>
            }

            // require SSL if mandatory
<span class="fc bfc" id="L458" title="All 2 branches covered.">            if (!req.isSecure()) {</span>
<span class="fc" id="L459">                resp.sendError(HttpURLConnection.HTTP_FORBIDDEN, &quot;SSL Required&quot;);</span>
<span class="fc" id="L460">                return AuthStatus.SEND_FAILURE;</span>
            }

<span class="fc" id="L463">            final String subject = getSubject(req);</span>

            // Check if there is no subject then redirect to login endpoint
<span class="fc bfc" id="L466" title="All 2 branches covered.">            if (subject == null) {</span>
<span class="fc" id="L467">                return handleRedirectToLoginEndpoint(req, resp);</span>
            }

<span class="fc" id="L470">            handler.handle(new Callback[] {</span>
                new CallerPrincipalCallback(client, subject),
                new GroupPrincipalCallback(client, GROUPS)
            });
<span class="fc" id="L474">            return AuthStatus.SUCCESS;</span>

<span class="fc" id="L476">        } catch (final IOException</span>
            | ServletException
            | UnsupportedCallbackException e) {
<span class="fc" id="L479">            LOG.throwing(TestServerAuthModule.class.getName(), &quot;validateRequest&quot;, e);</span>
<span class="fc" id="L480">            throw new AuthException(e.getMessage());</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>